package com.huwei.dailytest.jishiTest;


public class Day0226 {
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();

    }

    /**
     * 如果三个正整数A B C ,A²+B²=C²则为勾股数
     * 如果ABC之间两两互质，即A与B A与C B与C均互质没有公约数，
     * 则称其为勾股数元组。
     * 请求出给定n m 范围内所有的勾股数元组
     * 输入描述
     * 起始范围 1<n<10000    n<m<10000
     * 输出目描述
     * abc 保证a<b<c输出格式  a b c
     * 多组勾股数元组 按照a升序b升序 c升序的排序方式输出。
     * 给定范围内，找不到勾股数元组时，输出  Na
     * <p>
     * 案例
     * 输入
     * 1
     * 20
     * 输出
     * 3 4 5
     * 5 12 13
     * 8 15 17
     * <p>
     * 输入
     * 5
     * 10
     * 输出
     * Na
     */
    private static void test5() {
    }

    /**
     * 给定两个整数数组
     * array1 array2  数组元素按升序排列
     * 假设从arr1 arr2中分别取出一个元素，可构成一对元素
     * 现在需要取出k对元素，并对取出的所有元素求和
     * 计算和的最小值
     * 注意：两对元素对应arr1 arr2的下标是相同的
     * 视为同一对元素
     * <p>
     * 输入描述
     * 输入两行数组arr1 arr2
     * 每行首个数字为数组大小size   0<size<=100
     * arr1，2中的每个元素   0< <1000
     * 接下来一行  正整数k   0<k<=arr1.size * arr2.size
     * 输出描述
     * 满足要求的最小值
     * <p>
     * 例子
     * <p>
     * 输入
     * 3 1 1 2
     * 3 1 2 3
     * 2
     * <p>
     * 输出
     * 4
     * <p>
     * 说明：用例中需要取两个元素，
     * 取第一个数组第0个元素与第二个数组第0个元素组成一个元素
     * [1,1]
     * 取第一个数组第1个元素与第二个数组第0个元素组成一个元素
     * [1,1]
     * <p>
     * 求和为1+1+1+1=4 ,满足要求最小
     */
    private static void test4() {
    }

    /**
     * 给出n阶方阵里所有数
     * 求方阵里所有数的和
     * 输入描述：
     * 输入有多个测试用例
     * 每个测试用例第一个第一个整数n   n<=1000 表示方阵阶数为n
     * 接下来是n行的数字，每行n个数字用空格隔开
     * 输出描述：
     * 输出一个整数表示n阶方阵的和
     * 例子：
     * 输入
     * 3
     * 1 2 3
     * 2 1 3
     * 3 2 1
     * 输出
     * 18
     */
    private static void test3() {
    }

    /**
     * TLV编码是按 Tag Length  Value格式进行编码的
     * 一段码流中的信元用tag标识，tag在码流中唯一不重复
     * length表示信元value的长度  value表示信元的值
     * 码流以某信元的tag开头 ，tag固定占一个字节
     * length固定占两个字节，字节序为小端序
     * 现给定tlv格式编码的码流以及需要解码的信元tag
     * 请输出该信元的value
     * <p>
     * 输入码流的16机制字符中，不包括小写字母
     * 且要求输出的16进制字符串中也不要包含字符字母
     * 码流字符串的最大长度不超过50000个字节
     * <p>
     * 输入描述
     * 第一行为第一个字符串 ，表示待解码信元的tag
     * 输入第二行为一个字符串， 表示待解码的16进制码流
     * 字节之间用空格分割
     * 输出描述
     * 输出一个字符串，表示待解码信元以16进制表示的value
     * <p>
     * 例子：
     * 输入：
     * 31
     * 32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC
     * <p>
     * 输出
     * 32 33
     * <p>
     * 说明：
     * 需要解析的信源的tag是31
     * 从码流的起始处开始匹配，tag为32的信元长度为1(01 00,小端序表示为1)
     * 第二个信元的tag为90 其长度为2
     * 第三个信元的tag为30 其长度为3
     * 第四个信元的tag为31 其长度为2(02 00)
     * 所以返回长度后面的两个字节即可 为 32 33
     */
    private static void test2() {
    }

    /**
     * 一天一只顽猴想要从山脚爬到山顶
     * 途中经过一个有n个台阶的阶梯，但是这个猴子有个习惯，每一次只跳1步或3步
     * 试问？猴子通过这个阶梯有多少种不同的跳跃方式
     * <p>
     * 输入描述：
     * 输入只有一个这个数n    0<n<50
     * 此阶梯有多个台阶
     * 输出描述：
     * 有多少种跳跃方式
     * <p>
     * 实例:
     * 输入
     * 50
     * 输出
     * 122106097
     * <p>
     * 输入
     * 3
     * 输出
     * 2
     */
    private static void test1() {
    }
}
